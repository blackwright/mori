'use client';

import { useDetailsSearchParams } from '@/app/hooks';
import { Drawer, ErrorMessage, FullScreenMain } from '@/components';
import { Canvas } from '@react-three/fiber';
import { AnimatePresence } from 'motion/react';
import { Suspense, useCallback, useReducer } from 'react';
import { MathUtils } from 'three';
import { write } from '../actions';
import { reducer } from './reducer';
import { Incoming } from './scene/text/Incoming';
import { Outgoing } from './scene/text/Outgoing';
import { Wind } from './scene/wind';
import { Controls } from './ui/controls';
import { ImageData } from './ui/image-data';
import { createIncomingTextGeometry } from './utils';

type Props = {
  initialText: string;
  initialError: string;
};

export function DuneIpsum({ initialText, initialError }: Props) {
  const [state, dispatch] = useReducer(reducer, {
    text: initialText,
    isLoading: false,
    isRendering: true,
    errorMessage: initialError,
    incomingTextState: null,
    outgoingTextState: null,
  });

  const [areDetailsOpen] = useDetailsSearchParams();

  const handleImageData = useCallback(
    (imageData: ImageData, particleGap: number) => {
      // canvas image data is a one-dimensional array of RGBA values per pixel
      const pointCoords: number[] = [];

      let i = 0;

      while (i < imageData.data.length) {
        const alpha = imageData.data[i + 3];

        if (alpha > 0) {
          const x = ((i / 4) % imageData.width) - imageData.width / 2;
          const y = -((i / 4 - x) / imageData.width - imageData.height / 2);

          pointCoords.push(x, y - 25, 0);
        }

        i += MathUtils.randInt(1, particleGap) * 4;
      }

      const position = Float32Array.from(pointCoords);

      dispatch({
        type: 'SET_INCOMING_TEXT',
        payload: createIncomingTextGeometry(position),
      });
    },
    [],
  );

  const handleComplete = useCallback(() => {
    dispatch({ type: 'COMPLETE_RENDERING' });
  }, []);

  const handleGenerate = async () => {
    if (state.isRendering) {
      return;
    }

    dispatch({ type: 'START_GENERATION' });

    try {
      const newText = await write();
      dispatch({ type: 'GENERATION_SUCCESS', payload: newText });
    } catch (e) {
      if (e instanceof Error) {
        dispatch({ type: 'GENERATION_ERROR', payload: e.message });
      }
    }
  };

  return (
    <FullScreenMain>
      <Canvas
        orthographic={true}
        camera={{ position: [0, 0, 1], far: 500 }}
        resize={{ scroll: true, debounce: { scroll: 50, resize: 0 } }}
      >
        <Suspense fallback={null}>
          {state.incomingTextState && (
            <Incoming
              key={`incoming-${state.incomingTextState.key}`}
              geometry={state.incomingTextState.geometry}
              incomingDelay={2}
              maxVisibleTime={state.incomingTextState.maxVisibleTime}
              onComplete={handleComplete}
            />
          )}

          {state.outgoingTextState && (
            <Outgoing
              key={`outgoing-${state.outgoingTextState.key}`}
              geometry={state.outgoingTextState.geometry}
            />
          )}

          <Wind isRendering={state.isRendering} />
        </Suspense>
      </Canvas>

      <div className="absolute top-0 left-0 flex h-full w-full flex-col pb-6">
        <Controls
          text={state.text}
          onGenerate={handleGenerate}
          isLoading={state.isLoading || state.isRendering}
        />

        <ImageData text={state.text} onChange={handleImageData} />
      </div>

      {!!state.errorMessage && (
        <ErrorMessage className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2">
          {state.errorMessage}
        </ErrorMessage>
      )}

      <AnimatePresence>
        {areDetailsOpen && !state.errorMessage && (
          <Drawer>
            <p>
              A Dune-themed lorem ipsum generator built with react-three-fiber.
            </p>
            <p>
              Text is generated by ChatGPT and painted to an invisible canvas
              element, formatted to fit the screen. This allows the text to be
              sized, broken up, and positioned in a more reliable manner across
              varying screen sizes.
            </p>
            <p>
              From the canvas, pixel data is converted into position vectors.
              Each particle is associated with a time value that determines when
              it becomes visible (pixels further to the right generally become
              visible later).
            </p>
            <p>
              Finally, particles are rendered by a vertex shader utilizing the
              position values, while the &quot;animation&quot; is accomplished
              with a fragment shader that either paints or discards pixels based
              on elapsed time.
            </p>
          </Drawer>
        )}
      </AnimatePresence>
    </FullScreenMain>
  );
}
